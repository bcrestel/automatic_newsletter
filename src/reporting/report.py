import logging
from enum import Enum
from typing import Dict

import pandas as pd

from src.scoring.structured_news_stories import SCORE_COL

logger = logging.getLogger(__name__)


class Categories(Enum):
    COMPETTIVE_INTELLIGENCE = "competitive_intelligence"
    THEMES = "themes"
    FUNDING = "Funding"
    EVALUATION = "Evaluation"


SEPARATOR_LONG = "=" * 60 + "\n"
SEPARATOR_SHORT = "=" * 20 + "\n"

themes_to_exclude = set(["AI&GenAI", "Model", "Funding", "Evaluation"])

COL_TAGS = [
    "competitive_intelligence",
    "themes",
    "market_intelligence",
    "personalities",
]


class Report:
    # TODO: Add logging
    def __init__(self, df_scored_news_stories: pd.DataFrame, target_fields: Dict):
        """Build a report from scored news stories

        Args:
            df_scored_news_stories (pd.DataFrame): scored news stories
            target_fields (Dict): dictionary generated by GoogleSheets class
        """
        if SCORE_COL in df_scored_news_stories.columns:
            self.df_ns = df_scored_news_stories
        else:
            raise KeyError(f"Missing column {SCORE_COL} in df_scored_news_stories")
        self.target_fields = target_fields
        self._validate_categories()

    def _validate_categories(self):
        tabs = self.target_fields.keys()
        for tab in [Categories.COMPETTIVE_INTELLIGENCE.value, Categories.THEMES.value]:
            if tab not in tabs:
                logger.error(f"Missing tab {tab} in the Google Sheets")
                raise KeyError(f"Missing tab {tab} in the Google Sheets")
        # the rest
        th_sheet = self.target_fields[Categories.THEMES.value].keys()
        for cat in [Categories.FUNDING.value, Categories.EVALUATION.value]:
            if cat not in th_sheet:
                logger.error(f"Missing tab {cat} in the Google Sheets")
                raise KeyError(f"Missing tab {cat} in the Google Sheets")

    def filtered_news_stories(
        self, min_score_threshold: int, min_nb_entries: int, min_pct_entries: float
    ) -> Dict[str, pd.DataFrame]:
        """Select relevant news stories from self.df_ns for the report

        Args:
            min_score_threshold (int): min score required to be selected
            min_nb_entries (int): min nb of news stories to keep
            min_pct_entries (float): min percentage of news stories to keep

        Returns:
            Dict[str, pd.DataFrame]: selected news stories from self.df_ns for each section of the report
                sections are "competitive_intelligence", "themes", "funding", "evaluation"
        """
        # Validate input arguments
        if not (0 < min_pct_entries < 1.0):
            raise ValueError(
                f"Received wrong input argument min_pct_entries = {min_pct_entries}"
            )
        # only keep entries with non-zero score
        df_nonzero = self.df_ns[self.df_ns[SCORE_COL] > 0]
        news_stories_for_report = {}
        # section: competitive intelligence
        news_stories_for_report[Categories.COMPETTIVE_INTELLIGENCE.name] = df_nonzero[
            df_nonzero[Categories.COMPETTIVE_INTELLIGENCE.value].apply(lambda x: len(x))
            > 0
        ]
        # section: funding
        news_stories_for_report[Categories.FUNDING.name] = df_nonzero[
            df_nonzero[Categories.THEMES.value].apply(
                lambda x: Categories.FUNDING.value in x
            )
        ]
        # section: evaluation
        news_stories_for_report[Categories.EVALUATION.name] = df_nonzero[
            df_nonzero[Categories.THEMES.value].apply(
                lambda x: Categories.EVALUATION.value in x
            )
        ]
        # rest of the categories:
        # Find minimum score corresponding to most conservative of min_nb_entries and min_pct_entries
        df_sorted_news_stories = df_nonzero.sort_values(SCORE_COL, ascending=False)
        min_pct_entries_in_nb = int(len(df_sorted_news_stories) * min_pct_entries)
        min_entries = max(min_nb_entries, min_pct_entries_in_nb)
        score_min_entries = df_sorted_news_stories.iloc[min_entries - 1][SCORE_COL]
        logger.debug(
            f"min_nb_entries={min_nb_entries}, "
            + f"min_pct_entries_in_db={min_pct_entries_in_nb}, "
            + f"min_entries={min_entries}, "
            + f"score_min_entries={score_min_entries}"
        )
        logger.debug(df_sorted_news_stories.iloc[min_entries - 1])
        if score_min_entries < min_score_threshold:
            logger.warning(
                f"The score to maintain a minimum "
                + f"number of entries is {score_min_entries}, "
                + f"which is less than the "
                + f"target threshold {min_score_threshold}."
            )
            min_score = score_min_entries
        else:
            min_score = min_score_threshold
        news_stories_for_report[Categories.THEMES.name] = df_sorted_news_stories[
            df_sorted_news_stories[SCORE_COL] >= min_score
        ]
        return news_stories_for_report

    def create_report(self, news_stories_for_report: Dict[str, pd.DataFrame]) -> str:
        next_line = "\n\n" + SEPARATOR_LONG + "\n\n"
        # Competitive intelligence
        ns = news_stories_for_report[Categories.COMPETTIVE_INTELLIGENCE.name]
        report = "# Competitive Intelligence\n" + self._format_section(ns)
        report += next_line
        # Evaluation
        ns = news_stories_for_report[Categories.EVALUATION.name]
        report += "# Evaluation\n" + self._format_section(ns)
        report += next_line
        # Funding
        ns = news_stories_for_report[Categories.FUNDING.name]
        report += "# Funding\n" + self._format_section(ns)
        report += next_line
        # Various Themes
        report += "# Themes\n"
        df_exploded = news_stories_for_report[Categories.THEMES.name][
            Categories.THEMES.value
        ].explode()
        all_themes = set(df_exploded)
        themes_to_include = list(all_themes - themes_to_exclude)
        for theme in themes_to_include:
            _df = news_stories_for_report[Categories.THEMES.name].loc[
                df_exploded[df_exploded.str.contains(theme)].index
            ]
            report += f"\n## {theme}\n" + self._format_section(_df)
        idx_included = set(df_exploded[df_exploded.isin(themes_to_include)].index)
        # TODO: Add indexes from previous categories (Funding, Evaluation, Competitive Intelligence)
        idx_left = list(
            set(news_stories_for_report[Categories.THEMES.name].index) - idx_included
        )
        df_left = news_stories_for_report[Categories.THEMES.name].loc[idx_left]
        report += "\n## The rest\n" + self._format_section(df_left)
        # TODO: Add articles that were not selected, ranked according to their score
        return report

    def _format_section(self, news_stories: pd.DataFrame) -> str:
        if len(news_stories) == 0:
            return "Nothing to see here!"
        else:
            out = ""
            for idx in news_stories.index:
                ns = news_stories.loc[idx]
                tags = ns[COL_TAGS].sum()
                out += (
                    f"\u2022 {ns['title']} ({ns['url']}):\n"
                    + f"\tScore: {ns['score']} (tags: {tags})\n"
                    + f"\tSummary: {ns['news_summary']}\n"
                )
            return out
