import logging
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd

from src.config import VERSION
from src.saving.database import Database
from src.utils.io.text import save_to_text
from src.utils.list import flatten_list_of_lists

logger = logging.getLogger(__name__)


class Categories(Enum):
    COMPETTIVE_INTELLIGENCE = "competitive_intelligence"
    THEMES = "themes"
    FUNDING = "Funding"
    EVALUATION = "Evaluation"


SEPARATOR_LONG = "=" * 60 + "\n"
SEPARATOR_SHORT = "=" * 20 + "\n"
COL_TAGS = [
    "competitive_intelligence",
    "themes",
    "market_intelligence",
    "personalities",
]
COLUMN_INCLUDED_IN_REPORT = "included_in_report"


class Report:
    def __init__(
        self,
        report_date_range: List[str],
        target_fields: Dict,
        df_scored_news_stories: Optional[pd.DataFrame] = None,
        path_to_db: Optional[str] = None,
        debug_mode: bool = True,
        score_col: str = "score_category_count",
    ):
        """Build a report from scored news stories. News stories can be passed directly or queries from a Database

        Args:
            report_date_range (List[str]): start_date and end_date for the dates of the report
            target_fields (Dict): dictionary generated by GoogleSheets class
            df_scored_news_stories (pd.DataFrame): scored news stories
            path_to_db (str): path to Database
            debug_mode (bool): debug mode will include more details. For once, we include the non-selected news stories in the report
        """
        if len(report_date_range) == 2:
            self.start_date, self.end_date = report_date_range
        else:
            raise ValueError(
                f"report_date_range must be a list of length 2. "
                + "Instead got length {len(report_date_range)}."
            )
        self.target_fields = target_fields
        self.df_ns = self._build_df_ns(
            df_scored_news_stories=df_scored_news_stories, path_to_db=path_to_db
        )
        self._validate_categories()
        self.debug_mode = debug_mode
        self.score_col = score_col

    def create_report(
        self,
        min_score_threshold: float = 3.0,
        min_nb_entries: int = 5,
        min_pct_entries: float = 0.1,
        path_folder_log: str = "log/",
    ) -> str:
        news_stories_for_report = self._filtered_news_stories(
            min_score_threshold=min_score_threshold,
            min_nb_entries=min_nb_entries,
            min_pct_entries=min_pct_entries,
        )
        self._log_df_news_stories_for_report(
            news_stories_for_report=news_stories_for_report,
            path_to_log=self.get_path_to_report_log(
                log_type="df_news_stories",
                extension="parquet",
                path_folder=path_folder_log,
            ),
        )
        if self.debug_mode:
            news_stories_for_report["Non-Selected News Stories"] = self.df_ns[
                ~self.df_ns[COLUMN_INCLUDED_IN_REPORT]
            ]
        report_str = self._create_report_from_news_stories(
            news_stories_for_report=news_stories_for_report
        )
        report_path = self.get_path_to_report_log(
            log_type="report", extension="txt", path_folder=path_folder_log
        )
        save_to_text(file_path=report_path, content=report_str)
        logger.info(f"Report in text format was saved to {report_path}")
        return report_str

    def get_path_to_report_log(self, log_type: str, extension: str, path_folder) -> str:
        now = datetime.today()
        formatted_now = now.strftime("%Y%m%d%H%M%S")
        file_name = Path(
            f"{self.start_date}_{self.end_date}_{log_type}_{formatted_now}_v{VERSION}.{extension}"
        )
        path_to_report_log = Path(path_folder)
        path_to_report_log.mkdir(parents=True, exist_ok=True)
        return path_to_report_log / file_name

    def _build_df_ns(
        self, df_scored_news_stories: Optional[pd.DataFrame], path_to_db: Optional[str]
    ) -> pd.DataFrame:
        if path_to_db is not None:
            db = Database(path_to_db=path_to_db)
            self.df_ns = db.get_data_from_range_dates(
                start_date=self.start_date, end_date=self.end_date
            )
        elif df_scored_news_stories is not None:
            if self.score_col in df_scored_news_stories.columns:
                self.df_ns = df_scored_news_stories
            else:
                logger.debug(
                    f"df_scored_news_stories has columns: {df_scored_news_stories.columns}"
                )
                raise KeyError(
                    f"Missing column {self.score_col} in df_scored_news_stories"
                )
        else:
            raise ValueError(
                "You must define one of path_to_db and df_scored_news_stories."
            )

    def _validate_categories(self):
        tabs = self.target_fields.keys()
        for tab in [Categories.COMPETTIVE_INTELLIGENCE.value, Categories.THEMES.value]:
            if tab not in tabs:
                logger.debug(f"Google Sheets has tabs: {tabs}")
                raise KeyError(f"Missing tab {tab} in the Google Sheets")
        # the rest
        th_sheet = self.target_fields[Categories.THEMES.value].keys()
        for cat in [Categories.FUNDING.value, Categories.EVALUATION.value]:
            if cat not in th_sheet:
                logger.debug(f"Google Sheets has tabs: {th_sheet}")
                raise KeyError(f"Missing tab {cat} in the Google Sheets")

    def _filtered_news_stories(
        self,
        min_score_threshold: float,
        min_nb_entries: int,
        min_pct_entries: float,
        top_k: int = 3,
    ) -> Dict[str, pd.DataFrame]:
        """Select relevant news stories from self.df_ns for the report

        Args:
            min_score_threshold (int): min score required to be selected
            min_nb_entries (int): min nb of news stories to keep
            min_pct_entries (float): min percentage of news stories to keep

        Returns:
            Dict[str, pd.DataFrame]: selected news stories from self.df_ns for each section of the report
                sections are "competitive_intelligence", "themes", "funding", "evaluation"
        """
        # Validate input arguments
        if not (0 < min_pct_entries < 1.0):
            raise ValueError(
                f"Received wrong input argument min_pct_entries = {min_pct_entries}"
            )
        # Filter: only keep entries with non-zero score
        df_nonzero = self.df_ns[self.df_ns[self.score_col] > 0.0]
        news_stories_for_report = {}
        # Section: competitive intelligence
        news_stories_for_report[Categories.COMPETTIVE_INTELLIGENCE.name] = df_nonzero[
            df_nonzero[Categories.COMPETTIVE_INTELLIGENCE.value].apply(lambda x: len(x))
            > 0
        ]
        # Section: funding; evaluation
        for cat in [Categories.FUNDING, Categories.EVALUATION]:
            news_stories_for_report[cat.name] = df_nonzero[
                df_nonzero[Categories.THEMES.value].apply(lambda x: cat.value in x)
            ]
        # Section: Themes
        df_min_score = self._get_df_min_score(
            df_nonzero=df_nonzero,
            min_pct_entries=min_pct_entries,
            min_nb_entries=min_nb_entries,
            min_score_threshold=min_score_threshold,
        )
        themes_to_exclude = ["AI&GenAI", "Model", "Funding", "Evaluation"]
        leading_themes = self._top_k_themes(
            df=df_min_score, k=top_k, themes_to_exclude=themes_to_exclude
        )
        for theme in leading_themes:
            news_stories_for_report[f"{Categories.THEMES.name}-{theme}"] = (
                self._get_df_from_theme(df_min_score, theme)
            )
        idx_so_far = self._get_idx_from_dict_of_df(news_stories_for_report)
        idx_other = df_min_score.index.difference(idx_so_far)
        news_stories_for_report[f"{Categories.THEMES.name}-Other"] = df_min_score.loc[
            idx_other
        ]
        return news_stories_for_report

    def _log_df_news_stories_for_report(
        self, news_stories_for_report: Dict[str, pd.DataFrame], path_to_log: str
    ) -> None:
        # Add "included_in_report" column in self.df_ns
        selected_indices = self._get_idx_from_dict_of_df(news_stories_for_report)
        logger.debug(
            f"Tagged {len(selected_indices)} news stories in df_ns as included in the report."
        )
        self.df_ns[COLUMN_INCLUDED_IN_REPORT] = False
        self.df_ns.loc[selected_indices, COLUMN_INCLUDED_IN_REPORT] = True
        self.df_ns.to_parquet(path=path_to_log)
        logger.info(f"df_ns saved to {path_to_log}")

    def _create_report_from_news_stories(
        self, news_stories_for_report: Dict[str, pd.DataFrame]
    ) -> str:
        next_line = "\n\n" + SEPARATOR_LONG + "\n\n"
        report = ""
        for section_title, df_section in news_stories_for_report.items():
            report += f"# {section_title}\n" + self._format_section(df_section)
            report += next_line
        return report

    def _get_idx_from_dict_of_df(self, dict_df: Dict[str, pd.DataFrame]) -> list[int]:
        return list(set(flatten_list_of_lists([df.index for df in dict_df.values()])))

    def _get_df_min_score(
        self,
        df_nonzero: pd.DataFrame,
        min_pct_entries: float,
        min_nb_entries: int,
        min_score_threshold: float,
    ) -> pd.DataFrame:
        """Find minimum score corresponding to most conservative of min_nb_entries and min_pct_entries

        Args:
            df_nonzero (pd.DataFrame): filtered dataframe of news stories

        Returns:
            pd.DataFrame: df filtered according to self.params
        """
        df_sorted_news_stories = df_nonzero.sort_values(self.score_col, ascending=False)
        min_pct_entries_in_nb = int(len(df_sorted_news_stories) * min_pct_entries)
        min_entries = max(min_nb_entries, min_pct_entries_in_nb)
        score_min_entries = df_sorted_news_stories.iloc[min_entries - 1][self.score_col]
        logger.debug(
            f"min_nb_entries={min_nb_entries}, "
            + f"min_pct_entries_in_db={min_pct_entries_in_nb}, "
            + f"min_entries={min_entries}, "
            + f"score_min_entries={score_min_entries}"
        )
        logger.debug(df_sorted_news_stories.iloc[min_entries - 1])
        if score_min_entries < min_score_threshold:
            logger.warning(
                f"The score to maintain a minimum "
                + f"number of entries is {score_min_entries}, "
                + f"which is less than the "
                + f"target threshold {min_score_threshold}."
            )
            min_score = score_min_entries
        else:
            min_score = min_score_threshold
        return df_sorted_news_stories[
            df_sorted_news_stories[self.score_col] >= min_score
        ]

    def _top_k_themes(
        self, df: pd.DataFrame, k: int = 3, themes_to_exclude: list[str] = []
    ) -> Optional[str]:
        ranked_themes = (
            (df["themes"] + df["market_intelligence"]).explode().value_counts()
        )
        top_k_themes = []
        for theme in ranked_themes.index:
            if len(top_k_themes) == k:
                break
            if theme not in themes_to_exclude and ranked_themes.loc[theme].item() > 1:
                top_k_themes.append(theme)
        return top_k_themes

    def _get_df_from_theme(self, df: pd.DataFrame, theme: str) -> pd.DataFrame:
        themes_exploded = (df["themes"] + df["market_intelligence"]).explode()
        idx = themes_exploded[themes_exploded == theme].index
        return df.loc[idx]

    def _format_section(self, news_stories: pd.DataFrame) -> str:
        if len(news_stories) == 0:
            logger.debug(f"news_stories: {news_stories}")
            return "Nothing to see here!"
        else:
            out = ""
            for idx in news_stories.index:
                ns = news_stories.loc[idx]
                tags = ns[COL_TAGS].sum()
                out += (
                    f"\u2022 {ns['title']} ({ns['url']}):\n"
                    + f"\tScore: {ns['score']} (tags: {tags})\n"
                    + f"\tSummary: {ns['news_summary']}\n"
                )
            return out
