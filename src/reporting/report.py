import logging
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd

from src.scoring.structured_news_stories import SCORE_COL
from src.utils.list import flatten_list_of_lists

logger = logging.getLogger(__name__)


class Categories(Enum):
    COMPETTIVE_INTELLIGENCE = "competitive_intelligence"
    THEMES = "themes"
    FUNDING = "Funding"
    EVALUATION = "Evaluation"


SEPARATOR_LONG = "=" * 60 + "\n"
SEPARATOR_SHORT = "=" * 20 + "\n"

COL_TAGS = [
    "competitive_intelligence",
    "themes",
    "market_intelligence",
    "personalities",
]

COLUMN_INCLUDED_IN_REPORT = "included_in_report"

VERSION = "1.0"


class Report:
    def __init__(
        self,
        df_scored_news_stories: pd.DataFrame,
        target_fields: Dict,
        report_date_range: List[str],
    ):
        """Build a report from scored news stories

        Args:
            df_scored_news_stories (pd.DataFrame): scored news stories
            target_fields (Dict): dictionary generated by GoogleSheets class
            report_date_range (List[str]): start_date and end_date for the dates of the report
        """
        if SCORE_COL in df_scored_news_stories.columns:
            self.df_ns = df_scored_news_stories
        else:
            logger.debug(
                f"df_scored_news_stories has columns: {df_scored_news_stories.columns}"
            )
            raise KeyError(f"Missing column {SCORE_COL} in df_scored_news_stories")
        self.target_fields = target_fields
        self._validate_categories()
        self.start_date, self.end_date = report_date_range

    def create_report(self, params: Dict = {}) -> str:
        _params = {
            "min_score_threshold": 3,
            "min_nb_entries": 5,
            "min_pct_entries": 0.1,
        }
        _params.update(params)
        news_stories_for_report = self._filtered_news_stories(**_params)
        self._log_df(
            news_stories_for_report=news_stories_for_report,
            path_to_log=self.get_path_to_report_log(),
        )
        report_str = self._create_report_from_news_stories(
            news_stories_for_report=news_stories_for_report
        )
        return report_str

    def get_path_to_report_log(self, path_folder: str = "log/") -> str:
        now = datetime.today()
        formatted_now = now.strftime("%Y%m%d%H%M%S")
        file_name = Path(
            f"log_report_{self.start_date}_{self.end_date}_{formatted_now}.parquet"
        )
        path_to_report_log = Path(path_folder)
        path_to_report_log.mkdir(parents=True, exist_ok=True)
        return path_to_report_log / file_name

    def _validate_categories(self):
        tabs = self.target_fields.keys()
        for tab in [Categories.COMPETTIVE_INTELLIGENCE.value, Categories.THEMES.value]:
            if tab not in tabs:
                logger.debug(f"Google Sheets has tabs: {tabs}")
                raise KeyError(f"Missing tab {tab} in the Google Sheets")
        # the rest
        th_sheet = self.target_fields[Categories.THEMES.value].keys()
        for cat in [Categories.FUNDING.value, Categories.EVALUATION.value]:
            if cat not in th_sheet:
                logger.debug(f"Google Sheets has tabs: {th_sheet}")
                raise KeyError(f"Missing tab {cat} in the Google Sheets")

    def _filtered_news_stories(
        self, min_score_threshold: float, min_nb_entries: int, min_pct_entries: float, top_k: int = 3
    ) -> Dict[str, pd.DataFrame]:
        """Select relevant news stories from self.df_ns for the report

        Args:
            min_score_threshold (int): min score required to be selected
            min_nb_entries (int): min nb of news stories to keep
            min_pct_entries (float): min percentage of news stories to keep

        Returns:
            Dict[str, pd.DataFrame]: selected news stories from self.df_ns for each section of the report
                sections are "competitive_intelligence", "themes", "funding", "evaluation"
        """
        # Validate input arguments
        if not (0 < min_pct_entries < 1.0):
            raise ValueError(
                f"Received wrong input argument min_pct_entries = {min_pct_entries}"
            )
        # Filter: only keep entries with non-zero score
        df_nonzero = self.df_ns[self.df_ns[SCORE_COL] > 0.0]
        news_stories_for_report = {}
        # Section: competitive intelligence
        news_stories_for_report[Categories.COMPETTIVE_INTELLIGENCE.name] = df_nonzero[
            df_nonzero[Categories.COMPETTIVE_INTELLIGENCE.value].apply(lambda x: len(x))
            > 0
        ]
        # Section: funding; evaluation
        for cat in [Categories.FUNDING, Categories.EVALUATION]:
            news_stories_for_report[cat.name] = df_nonzero[
                df_nonzero[Categories.THEMES.value].apply(lambda x: cat.value in x)
            ]
        # Section: Themes
        df_min_score = self._get_df_min_score(
            df_nonzero=df_nonzero,
            min_pct_entries=min_pct_entries,
            min_nb_entries=min_nb_entries,
            min_score_threshold=min_score_threshold,
        )
        themes_to_exclude = ["AI&GenAI", "Model", "Funding", "Evaluation"]
        leading_themes = self._top_k_themes(
            df=df_min_score, k=top_k, themes_to_exclude=themes_to_exclude
        )
        for theme in leading_themes:
            news_stories_for_report[f"{Categories.THEMES.name}-{theme}"] = (
                self._get_df_from_theme(df_min_score, theme)
            )
        idx_so_far = self._get_idx_from_dict_of_df(news_stories_for_report)
        idx_other = df_min_score.index.difference(idx_so_far)
        news_stories_for_report[f"{Categories.THEMES.name}-Other"] = df_min_score.loc[
            idx_other
        ]
        return news_stories_for_report

    def _log_df(
        self, news_stories_for_report: Dict[str, pd.DataFrame], path_to_log: str
    ) -> None:
        # Add "included_in_report" column in self.df_ns
        selected_indices = self._get_idx_from_dict_of_df(news_stories_for_report)
        logger.debug(f"Tagged {len(selected_indices)} news stories in df_ns as included in the report.")
        self.df_ns[COLUMN_INCLUDED_IN_REPORT] = False
        self.df_ns.loc[selected_indices, COLUMN_INCLUDED_IN_REPORT] = True
        self.df_ns.to_parquet(path=path_to_log)

    def _create_report_from_news_stories(
        self, news_stories_for_report: Dict[str, pd.DataFrame]
    ) -> str:
        next_line = "\n\n" + SEPARATOR_LONG + "\n\n"
        report = ""
        for section_title, df_section in news_stories_for_report.items():
            report += f"# {section_title}\n" + self._format_section(df_section)
            report += next_line
        return report

    def _get_idx_from_dict_of_df(self, dict_df: Dict[str, pd.DataFrame]) -> list[int]:
        return list(set(flatten_list_of_lists([df.index for df in dict_df.values()])))

    def _get_df_min_score(
        self,
        df_nonzero: pd.DataFrame,
        min_pct_entries: float,
        min_nb_entries: int,
        min_score_threshold: float,
    ) -> pd.DataFrame:
        """Find minimum score corresponding to most conservative of min_nb_entries and min_pct_entries

        Args:
            df_nonzero (pd.DataFrame): filtered dataframe of news stories

        Returns:
            pd.DataFrame: df filtered according to self.params
        """
        df_sorted_news_stories = df_nonzero.sort_values(SCORE_COL, ascending=False)
        min_pct_entries_in_nb = int(len(df_sorted_news_stories) * min_pct_entries)
        min_entries = max(min_nb_entries, min_pct_entries_in_nb)
        score_min_entries = df_sorted_news_stories.iloc[min_entries - 1][SCORE_COL]
        logger.debug(
            f"min_nb_entries={min_nb_entries}, "
            + f"min_pct_entries_in_db={min_pct_entries_in_nb}, "
            + f"min_entries={min_entries}, "
            + f"score_min_entries={score_min_entries}"
        )
        logger.debug(df_sorted_news_stories.iloc[min_entries - 1])
        if score_min_entries < min_score_threshold:
            logger.warning(
                f"The score to maintain a minimum "
                + f"number of entries is {score_min_entries}, "
                + f"which is less than the "
                + f"target threshold {min_score_threshold}."
            )
            min_score = score_min_entries
        else:
            min_score = min_score_threshold
        return df_sorted_news_stories[df_sorted_news_stories[SCORE_COL] >= min_score]

    def _top_k_themes(
        self, df: pd.DataFrame, k: int = 3, themes_to_exclude: list[str] = []
    ) -> Optional[str]:
        ranked_themes = (
            (df["themes"] + df["market_intelligence"]).explode().value_counts()
        )
        top_k_themes = []
        for theme in ranked_themes.index:
            if len(top_k_themes) == k:
                break
            if theme not in themes_to_exclude and ranked_themes.loc[theme].item() > 1:
                top_k_themes.append(theme)
        return top_k_themes

    def _get_df_from_theme(self, df: pd.DataFrame, theme: str) -> pd.DataFrame:
        themes_exploded = (df["themes"] + df["market_intelligence"]).explode()
        idx = themes_exploded[themes_exploded == theme].index
        return df.loc[idx]

    def _format_section(self, news_stories: pd.DataFrame) -> str:
        if len(news_stories) == 0:
            logger.debug(f"news_stories: {news_stories}")
            return "Nothing to see here!"
        else:
            out = ""
            for idx in news_stories.index:
                ns = news_stories.loc[idx]
                tags = ns[COL_TAGS].sum()
                out += (
                    f"\u2022 {ns['title']} ({ns['url']}):\n"
                    + f"\tScore: {ns['score']} (tags: {tags})\n"
                    + f"\tSummary: {ns['news_summary']}\n"
                )
            return out
