import logging
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd

from src.config import PATH_TO_LOGS_FOLDER, VERSION
from src.genai_model.summarizer import (
    Summarizer,
    SummarizerCompIntel,
    SummarizerMarketIntel,
)
from src.saving.database import Database
from src.utils.io.text import save_to_text
from src.utils.list import flatten_list_of_lists

logger = logging.getLogger(__name__)


class Categories(Enum):
    COMPET = "competitive_intelligence"
    THEMES = "themes"
    MARKET = "market_intelligence"
    FUNDING = "Funding"
    EVALUATION = "Evaluation"


SEPARATOR_LONG = "=" * 60 + "\n"
SEPARATOR_SHORT = "=" * 20 + "\n"
COL_TAGS = [
    "competitive_intelligence",
    "themes",
    "market_intelligence",
    "personalities",
]
COLUMN_INCLUDED_IN_REPORT = "included_in_report"


class Report:
    def __init__(
        self,
        report_date_range: List[str],
        target_fields: Dict,
        score_col: str,
        df_scored_news_stories: Optional[pd.DataFrame] = None,
        path_to_db: Optional[str] = None,
        debug_mode: bool = True,
    ):
        """Build a report from scored news stories. News stories can be passed directly or queries from a Database

        Args:
            report_date_range (List[str]): start_date and end_date for the dates of the report
            target_fields (Dict): dictionary generated by GoogleSheets class
            score_col (str): Column used to filter news stories
            df_scored_news_stories (pd.DataFrame): scored news stories
            path_to_db (str): path to Database
            debug_mode (bool): debug mode will include more details. For once, we include the non-selected news stories in the report
        """
        if len(report_date_range) == 2:
            self.start_date, self.end_date = report_date_range
            logger.info(
                f"Will generate report for range {self.start_date} to {self.end_date}"
            )
        else:
            raise ValueError(
                f"report_date_range must be a list of length 2. "
                + "Instead got length {len(report_date_range)}."
            )
        self.target_fields = target_fields
        self._validate_categories()
        self.score_col = score_col
        self.df_ns = self._build_df_ns(
            df_scored_news_stories=df_scored_news_stories, path_to_db=path_to_db
        )
        logger.info(f"Found {len(self.df_ns)} candidate news stories for this report.")
        if self.score_col not in self.df_ns:
            raise KeyError(f"Could not find column {self.score_col} in df_ns.")
        self.debug_mode = debug_mode

    def create_report(self) -> str:
        """Create the report in text string. Sections are:
        1. Competitive Intelligence
        2. Market Intelligence
        3. Technology Themes

        Returns:
            str: Formatted report in string format
        """
        # Competitive Intelligence
        compintel_report = self._build_comp_intel_report(df_ns=self.df_ns)
        # Market Intelligence
        marketintel_report = self._build_mkt_intel_report(self.df_ns)
        # Technology Themes
        techthemes_report = self._build_techthemes_report(self.df_ns)
        # format report
        report_str = (f"\n{SEPARATOR_LONG}\n").join(
            [compintel_report, marketintel_report, techthemes_report]
        )
        return report_str

    def _build_comp_intel_report(self, df_ns: pd.DataFrame) -> str:
        all_tags = df_ns[Categories.COMPET.value].explode().dropna().unique()
        summarizer = SummarizerCompIntel()
        comp_intel_report = ""
        for tag in all_tags:
            df_tag = self._get_df_from_tag(df=df_ns, tag=tag)
            tag_report = self._build_tag_report(df=df_tag, summarizer=summarizer)
            comp_intel_report += f"\u2022 {tag}: {tag_report}\n"
        if len(comp_intel_report) == 0:
            comp_intel_report = "Nothing to see here!"
        return "COMPETITIVE INTELLIGENCE\n" + comp_intel_report

    def _build_mkt_intel_report(self, df_ns: pd.DataFrame) -> str:
        # TODO: Fix it to select only the most active companies
        all_tags = df_ns[Categories.MARKET.value].explode().dropna().unique()
        summarizer = SummarizerMarketIntel()
        market_intel_report = ""
        for tag in all_tags:
            df_tag = self._get_df_from_tag(df=df_ns, tag=tag)
            tag_report = self._build_tag_report(df=df_tag, summarizer=summarizer)
            market_intel_report += f"\u2022 {tag}: {tag_report}\n"
        return "MARKET INTELLIGENCE\n" + market_intel_report

    def _build_techthemes_report(self, df_ns: pd.DataFrame) -> str:
        # TODO: Fix it to select only the most relevant themes
        # TODO: make sure that we only include themes when AI&GenAI is also present
        all_tags = df_ns[Categories.THEMES.value].explode().dropna().unique()
        summarizer = Summarizer()
        techthemes_report = ""
        blacklist_tags = ["AI&GenAI"]
        for tag in all_tags:
            if tag not in blacklist_tags:
                df_tag = self._get_df_from_tag(df=df_ns, tag=tag)
                tag_report = self._build_tag_report(df=df_tag, summarizer=summarizer)
                techthemes_report += f"\u2022 {tag}: {tag_report}\n"
        return "TECHNOLOGY THEMES\n" + techthemes_report

    def _build_tag_report(self, df: pd.DataFrame, summarizer: Summarizer) -> str:
        if len(df) == 0:
            tag_report = "Nothing to see here!"
        else:
            sources = ""
            text = ""
            for nb, idx in enumerate(df.index):
                ns = df.loc[idx]
                text += f"{ns['title']} : {ns['news_summary']}\n"
                sources += f"[{nb+1}] {ns['title']} ({ns['url']})\n"
            if len(df) == 1:
                summary = ns["news_summary"]
                sources_section = "\nSources:\n" + sources
            else:
                summary = summarizer.summarize_str(text)
                sources_section = "Sources:\n" + sources
            tag_report = summary + sources_section
        return tag_report

    def _build_df_ns(
        self, df_scored_news_stories: Optional[pd.DataFrame], path_to_db: Optional[str]
    ) -> pd.DataFrame:
        """Query the news stories, either from an input dataframe or from a database

        Args:
            df_scored_news_stories (Optional[pd.DataFrame]): Dataframe containing the news stories
            path_to_db (Optional[str]): path to a db (parquet format) where the news stories are stored

        Raises:
            KeyError: if the dataframe is missing certain columns
            ValueError: at least one of df_scored_news_stories or path_to_db must be passed

        Returns:
            pd.DataFrame: dataframe containing the news stories
        """
        if path_to_db is not None:
            logger.info(
                f"We'll use the news stories queried from the database {path_to_db}"
            )
            db = Database(path_to_db=path_to_db)
            df_ns = db.get_data_from_range_dates(
                start_date=self.start_date, end_date=self.end_date
            )
        elif df_scored_news_stories is not None:
            logger.info(f"We'll use the news stories provided by the dataframe.")
            if self.score_col in df_scored_news_stories.columns:
                logger.debug(
                    f"Column {self.score_col} found in df_scored_news_stories."
                )
                df_ns = df_scored_news_stories
            else:
                logger.debug(
                    f"df_scored_news_stories has columns: {df_scored_news_stories.columns}"
                )
                raise KeyError(
                    f"Missing column {self.score_col} in df_scored_news_stories"
                )
        else:
            raise ValueError(
                "You must define one of path_to_db and df_scored_news_stories."
            )
        return df_ns

    def _validate_categories(self):
        """Validate that the dict self.target_fields is correctly formatted

        Raises:
            KeyError: if a category is missing
        """
        tabs = self.target_fields.keys()
        for tab in [
            Categories.COMPET.value,
            Categories.THEMES.value,
            Categories.MARKET.value,
        ]:
            if tab not in tabs:
                logger.debug(f"Google Sheets has tabs: {tabs}")
                raise KeyError(f"Missing tab {tab} in the Google Sheets")
        # the rest
        th_sheet = self.target_fields[Categories.THEMES.value].keys()
        for cat in [Categories.FUNDING.value, Categories.EVALUATION.value]:
            if cat not in th_sheet:
                logger.debug(f"Google Sheets has tabs: {th_sheet}")
                raise KeyError(f"Missing tab {cat} in the Google Sheets")
        logger.info(f"Target fields were successfully verified.")

    def _get_df_from_tag(self, df: pd.DataFrame, tag: str) -> pd.DataFrame:
        """Return the rows of the dataframe that contain a certain theme

        Args:
            df (pd.DataFrame): dataframe of news stories
            tag(str): tag to query

        Returns:
            pd.DataFrame: slice of the input dataframe, df, corresponding only to the entries that contain that theme
        """
        themes_exploded = (
            df[Categories.COMPET.value]
            + df[Categories.THEMES.value]
            + df[Categories.MARKET.value]
        ).explode()
        idx = themes_exploded[themes_exploded == tag].index
        return df.loc[idx]

    def get_path_to_report_log(
        self, log_type: str, extension: str, path_folder: Path
    ) -> str:
        """Path of the file to log

        Args:
            log_type (str): type of file to log
            extension (str): file extension
            path_folder (Path): path to the log folder

        Returns:
            str: path in str format
        """
        now = datetime.today()
        formatted_now = now.strftime("%Y%m%d-%H%M%S")
        file_name = Path(
            f"{self.start_date}_{self.end_date}__{log_type}__{formatted_now}__v{VERSION}.{extension}"
        )
        path_to_report_log = path_folder
        path_to_report_log.mkdir(parents=True, exist_ok=True)
        return path_to_report_log / file_name

    def _log_df_news_stories_for_report(
        self, news_stories_for_report: Dict[str, pd.DataFrame], path_to_log: str
    ) -> None:
        # Add "included_in_report" column in self.df_ns
        selected_indices = self._get_idx_from_dict_of_df(news_stories_for_report)
        logger.debug(
            f"Tagged {len(selected_indices)} news stories in df_ns as included in the report."
        )
        self.df_ns[COLUMN_INCLUDED_IN_REPORT] = False
        self.df_ns.loc[selected_indices, COLUMN_INCLUDED_IN_REPORT] = True
        self.df_ns.to_parquet(path=path_to_log)
        logger.info(f"df_ns saved to {path_to_log}")

    def _get_idx_from_dict_of_df(self, dict_df: Dict[str, pd.DataFrame]) -> List[int]:
        """Get all the indices from multiple dataframes stored in a dict[str, pd.Dataframe]

        Args:
            dict_df (Dict[str, pd.DataFrame]): Dictionary of str to pd.DataFrame

        Returns:
            List[int]: List of indices
        """
        return list(set(flatten_list_of_lists([df.index for df in dict_df.values()])))

    def _top_k_themes(
        self, df: pd.DataFrame, k: int = 3, themes_to_exclude: List[str] = []
    ) -> List[str]:
        """

        Args:
            df (pd.DataFrame): _description_
            k (int, optional): _description_. Defaults to 3.
            themes_to_exclude (list[str], optional): _description_. Defaults to [].

        Returns:
            List[str]: List of top-k themes, in string format
        """
        ranked_themes = (
            (df["themes"] + df["market_intelligence"]).explode().value_counts()
        )
        top_k_themes = []
        for theme in ranked_themes.index:
            if len(top_k_themes) == k:
                break
            if theme not in themes_to_exclude and ranked_themes.loc[theme].item() > 1:
                top_k_themes.append(theme)
        return top_k_themes
